<!DOCTYPE html>

{% set chart_id = "plot-container-" + uuid %}

<div id="{{ chart_id }}">
  <style>
    {{ default_css | safe }}
    {{ additional_css | safe }}
  </style>
  {{ svg | safe }}
  <div class="tooltip" id="tooltip-{{ uuid }}"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<script>
  (function () {
    class PlotSVGParser {
      constructor(svg, tooltip, tooltip_x_shift, tooltip_y_shift) {
        this.svg = svg;
        this.tooltip = tooltip;
        this.tooltip_x_shift = tooltip_x_shift;
        this.tooltip_y_shift = tooltip_y_shift;
      }

      find_bars(svg, axes_class) {
        // select all #patch within the specific axes
        const bars = svg
          .selectAll(`g#${axes_class} g[id^="patch"]`)
          .filter(function () {
            const path = d3.select(this).select("path");
            // that have a clip-path attribute
            const clip = path.attr("clip-path");
            // starting with "url("
            return clip && clip.startsWith("url(");
          });

        bars.attr("class", "bar plot-element");
        return bars;
      }

      find_points(svg, axes_class, tooltip_groups) {
        const self = this;
        // select all <use> in #PathCollection within the specific axes
        const points = svg.selectAll(
          `g#${axes_class} g[id^="PathCollection"] use`
        );

        points.each(function (_, i) {
          d3.select(this).attr("data-group", tooltip_groups[i]);
        });
        points.attr("class", "point plot-element");
        return points;
      }

      find_lines(svg, axes_class) {
        // select all <path> of Line2D elements within the specific axes
        const lines = svg
          .selectAll(`g#${axes_class} g[id^="line2d"] path`)
          .filter(function () {
            return !this.closest('g[id^="matplotlib.axis"]');
          });

        lines.attr("class", "line plot-element");
        return lines;
      }

      find_areas(svg, axes_class) {
        // select all <path> of FillBetweenPolyCollection elements within the specific axes
        const areas = svg.selectAll(
          `g#${axes_class} g[id^="FillBetweenPolyCollection"] path`
        );
        areas.attr("class", "area plot-element");
        return areas;
      }

      nearest_element_from_mouse(mouseX, mouseY, elements) {
        let nearestElem = null;
        let minDist = Infinity;

        elements.each(function (_, i) {
          const bbox = this.getBBox();
          const cx = bbox.x + bbox.width / 2;
          const cy = bbox.y + bbox.height / 2;
          const dist = Math.hypot(mouseX - cx, mouseY - cy);
          if (dist < minDist) {
            minDist = dist;
            nearestElem = this;
          }
        });

        return nearestElem;
      }

      setHoverEffect(
        plot_element,
        axes_class,
        tooltip_labels,
        tooltip_groups,
        show_tooltip,
        hover_nearest
      ) {
        const self = this;

        if (hover_nearest) {
          const axesGroup = svg.select(`g#${axes_class}`);
          console.log(axesGroup);
          axesGroup
            .on("mousemove", function (event) {
              const [mouseX, mouseY] = d3.pointer(event);
              const allElements = axesGroup.selectAll(".plot-element");
              const nearestElem = self.nearest_element_from_mouse(
                mouseX,
                mouseY,
                allElements
              );

              allElements
                .classed("hovered", false)
                .classed("not-hovered", false);

              if (nearestElem) {
                const nodes = allElements.nodes();
                const i = nodes.indexOf(nearestElem);
                const group = tooltip_groups[i];

                allElements
                  .filter((_, j) => tooltip_groups[j] === group)
                  .classed("hovered", true);

                allElements
                  .filter((_, j) => tooltip_groups[j] !== group)
                  .classed("not-hovered", true);

                self.tooltip
                  .style("display", show_tooltip)
                  .style("left", event.pageX + self.tooltip_x_shift + "px")
                  .style("top", event.pageY + self.tooltip_y_shift + "px")
                  .html(tooltip_labels[i]);
              } else {
                tooltip.style("display", "none");
              }
            })
            .on("mouseout", function () {
              axesGroup
                .selectAll(".plot-element")
                .classed("hovered", false)
                .classed("not-hovered", false);
              self.tooltip.style("display", "none");
            });
        } else {
          plot_element
            .on("mouseover", function (event, d) {
              const nodes = plot_element.nodes();
              let i = nodes.indexOf(this);

              const hovered_group = tooltip_groups[i];
              plot_element.classed("not-hovered", true);
              plot_element
                .filter((_, j) => {
                  return tooltip_groups[j] === hovered_group;
                })
                .classed("not-hovered", false)
                .classed("hovered", true);

              self.tooltip
                .style("display", show_tooltip)
                .style("left", event.pageX + self.tooltip_x_shift + "px")
                .style("top", event.pageY + self.tooltip_y_shift + "px")
                .html(tooltip_labels[i]);
            })
            .on("mouseout", function () {
              plot_element
                .classed("not-hovered", false)
                .classed("hovered", false);
              self.tooltip.style("display", "none");
            });
        }
      }
    }

    const container = document.getElementById("{{ chart_id }}");

    const tooltip = d3.select("#tooltip-{{ uuid }}");
    const svg = d3.select(container).select("svg");

    const plot_data = JSON.parse(`{{ plot_data_json | tojson | safe }}`);
    const tooltip_x_shift = plot_data["tooltip_x_shift"];
    const tooltip_y_shift = -plot_data["tooltip_y_shift"];
    const axes = plot_data["axes"];

    const plotParser = new PlotSVGParser(
      svg,
      tooltip,
      tooltip_x_shift,
      tooltip_y_shift
    );

    // Process each axes that has tooltip configuration
    for (const axes_class in axes) {
      if (axes.hasOwnProperty(axes_class)) {
        const axe_data = axes[axes_class];
        const tooltip_labels = axe_data["tooltip_labels"];
        const tooltip_groups = axe_data["tooltip_groups"];
        const hover_nearest = axe_data["hover_nearest"] === "true";
        const show_tooltip = tooltip_labels.length === 0 ? "none" : "block";

        const lines = plotParser.find_lines(svg, axes_class);
        const bars = plotParser.find_bars(svg, axes_class);
        const points = plotParser.find_points(svg, axes_class, tooltip_groups);
        const areas = plotParser.find_areas(svg, axes_class);

        plotParser.setHoverEffect(
          points,
          axes_class,
          tooltip_labels,
          tooltip_groups,
          show_tooltip,
          hover_nearest
        );
        plotParser.setHoverEffect(
          lines,
          axes_class,
          tooltip_labels,
          tooltip_groups,
          show_tooltip,
          hover_nearest
        );
        plotParser.setHoverEffect(
          bars,
          axes_class,
          tooltip_labels,
          tooltip_groups,
          show_tooltip,
          hover_nearest
        );
        plotParser.setHoverEffect(
          areas,
          axes_class,
          tooltip_labels,
          tooltip_groups,
          show_tooltip,
          hover_nearest
        );
      }
    }
  })();
</script>

<script>
  // prettier-ignore
  {{ additional_javascript | safe }}
</script>
